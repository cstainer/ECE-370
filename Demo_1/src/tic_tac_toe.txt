#! /usr/bin/env python

import rospy
from std_msgs.msg import String
from tic_tac_toe_board import board_setup

# Global variables
flag = True
#          Q    W    E      A    S    D      Z    X    C
board = [[" ", " ", " "], [" ", " ", " "], [" ", " ", " "]]
winner = None


def go_home():
    global cmd_pub
    home = Twist()
    home.linear.x = -9.25
    home.lienar.y = 0.0
    home.lienar.z = 3.0
    cmd_pub.publish(home)
    rospy.sleep(5)  # TODO use wait_for_message on the /drone/gt_pose and loop until the drone is close enough


def knock_over(r, c, player):
    global cmd_pub
    move = Twist()

    # position values for calculating /cmd_vel messages
    vert_offset = -8
    red_offset = 0.75
    blue_offset = -0.75
    col = [3.5, 0, -3.5]
    row = [2.25, -1.25, -4.75]

    # approach the piece
    move.linear.x = vert_offset + row[r] - 1.5
    
    # apply the offset for the currently active player
    if player == "Red":
        move.linear.y = col[c] + red_offset
    elif player == "Blue":
        move.linear.y = col[c] + blue_offset
    
    move.linear.z = 3.0

    cmd_pub.publish(move)
    rospy.sleep(5)  # TODO use wait_for_message on the /drone/gt_pose and loop until the drone is close enough

    # descend
    move.linear.z = 1.3
    cmd_pub.publish(move)
    rospy.sleep(2)  # TODO use wait_for_message on the /drone/gt_pose and loop until the drone is close enough

    # CHARGE!
    move.linear.x = vert_offset + row[r] + 1.5
    cmd_pub.publish(move)
    rospy.sleep(2)  # TODO use wait_for_message on the /drone/gt_pose and loop until the drone is close enough


def win_checker(player=None)
    global board
    global winner

    # only 8 winning combos, so easy enough to just brute force it
    # horizontal wins
    if board[0][0] == player and board[0][1] == player and board[0][2] == player:
        winner = player
    elif board[1][0] == player and board[1][1] == player and board[1][2] == player:
        winner = player
    elif board[2][0] == player and board[2][1] == player and board [2][2] == player:
        winner = player
    # vertical wins
    elif board[0][0] == player and board[1][0] == player and board[2][0] == player:
        winner = player
    elif board[0][1] == player and board[1][1] == player and board[2][1] == player:
        winner = player
    elif board[0][2] == player and board[1][2] == player and board[2][2] == player:
        winner = player
    # diagonal wins
    elif board[0][0] == player and board[1][1] == player and board[2][2] == player:
        winner = player
    elif board[0][2] == player and board[1][1] == player and board[2][0] == player:
        winner = player


# Keyboard callback
def callback(msg=None):

    # parse the incoming message
    position = msg.data[:1]
    player = msg.data[1:]
    
    # local variables (and access to necessary globals) 
    response = String()
    global board
    global ttt_pub

    # decode the message position component
    if position == "q":
        # check if the position has already been claimed
        if board[0][0] == " ":    
        # if no, knock over the piece
            knock_over(0, 0, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "w":
        # check if the position has already been claimed
        if board[0][1] == " ":    
        # if no, knock over the piece
            knock_over(0, 1, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "e":
        # check if the position has already been claimed
        if board[0][2] == " ":    
        # if no, knock over the piece
            knock_over(0, 2, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "a":
        # check if the position has already been claimed
        if board[1][0] == " ":    
        # if no, knock over the piece
            knock_over(1, 0, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "s":
        # check if the position has already been claimed
        if board[1][1] == " ":    
        # if no, knock over the piece
            knock_over(1, 1, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "d":
        # check if the position has already been claimed
        if board[1][2] == " ":    
        # if no, knock over the piece
            knock_over(1, 2, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "z":
        # check if the position has already been claimed
        if board[2][0] == " ":    
        # if no, knock over the piece
            knock_over(2, 0, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "x":
        # check if the position has already been claimed
        if board[2][1] == " ":    
        # if no, knock over the piece
            knock_over(2, 1, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    elif position == "c":
        # check if the position has already been claimed
        if board[2][2] == " ":    
        # if no, knock over the piece
            knock_over(2, 2, player)
        else:
        # else publish fail response
            response.data = "failure"
            ttt_pub.publish(response)
    else:
    # else publish fail response
        response.data = "failure"
        ttt_pub.publish(response)
    
    # go home
    go_home()

    # check for the win
    win_checker(player)

    # if win publish win response
    if winner == player:
        response.data = "win" + player
        ttt_pub.publish(response)
    # else publish success response
    else:
        response.data = "success"
        ttt_pub.publish(response)


# Create the tic tac toe node
rospy.init_node("/ttt")

# Set up the board
board_setup()

# Set drone control mode to position
pos = Bool()
pos.data = True
pos_ctrl_pub = rospy.Publisher("/drone/posctrl", Bool, queue_size=1)
pos_ctrl_pub.publish(pos)

# Drone control publisher
cmd_pub = rospy.Publisher("/cmd_vel", Twist, queue_size=1)
go_home()

# Tic tac toe publisher
ttt_pub = rospy.Publisher("/ttt_ctl", String, queue_size=1)

# Keyboard subscriber
key_sub = rospy.Subscriber("/keyboard", String, callback)

# Run until told to do otherwise
rospy.spin()
